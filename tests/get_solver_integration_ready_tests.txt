Trying to make or-tools summonable by a higher level module (as in it uses or-tools as a sub-solver) in python.

This is  a log of command line inputs and outputs.
Each subsequent program is a duplicate of the previous, with some changes.

 As my basis CVRP program, I used the Python version of the complete program found here: https://developers.google.com/optimization/routing/cvrp
Technically the final product has two capacities - demand and vehicle fuel - but we only deal with demand for now.

First, let's check that python is working:
--------------------------------------------------------------------------
C:\Users\jc321076\github\or-tools>python tests/example_routing.py
Route for vehicle 0:
 0 ->  8 ->  6 ->  2 ->  5 -> 0
Distance of the route: 1552m

Route for vehicle 1:
 0 ->  7 ->  1 ->  4 ->  3 -> 0
Distance of the route: 1552m

Route for vehicle 2:
 0 ->  9 ->  10 ->  16 ->  14 -> 0
Distance of the route: 1552m

Route for vehicle 3:
 0 ->  12 ->  11 ->  15 ->  13 -> 0
Distance of the route: 1552m

Maximum of the route distances: 1552m

--------------------------------------------------------------------------


Okay, that works. Now, let's do the same but for the CVRP:
--------------------------------------------------------------------------
C:\Users\jc321076\github\or-tools>python tests/external_data_routing.py
Route for vehicle 0:
 0 Load(0) ->  1 Load(1) ->  4 Load(5) ->  3 Load(7) ->  15 Load(15) ->  0 Load(15)
Distance of the route: 2192m
Load of the route: 15

Route for vehicle 1:
 0 Load(0) ->  14 Load(4) ->  16 Load(12) ->  10 Load(14) ->  2 Load(15) ->  0 Load(15)
Distance of the route: 2192m
Load of the route: 15

Route for vehicle 2:
 0 Load(0) ->  7 Load(8) ->  13 Load(12) ->  12 Load(14) ->  11 Load(15) ->  0 Load(15)
Distance of the route: 1324m
Load of the route: 15

Route for vehicle 3:
 0 Load(0) ->  9 Load(1) ->  8 Load(9) ->  6 Load(13) ->  5 Load(15) ->  0 Load(15)
Distance of the route: 1164m
Load of the route: 15

Total distance of all routes: 6872m
Total load of all routes: 60

--------------------------------------------------------------------------


Can we solve external_data_routing.py when located outside the or-tools folder?
--------------------------------------------------------------------------
C:\Users\jc321076\github>python external_data_routing.py
Route for vehicle 0:
 0 Load(0) ->  1 Load(1) ->  4 Load(5) ->  3 Load(7) ->  15 Load(15) ->  0 Load(15)
Distance of the route: 2192m
Load of the route: 15

Route for vehicle 1:
 0 Load(0) ->  14 Load(4) ->  16 Load(12) ->  10 Load(14) ->  2 Load(15) ->  0 Load(15)
Distance of the route: 2192m
Load of the route: 15

Route for vehicle 2:
 0 Load(0) ->  7 Load(8) ->  13 Load(12) ->  12 Load(14) ->  11 Load(15) ->  0 Load(15)
Distance of the route: 1324m
Load of the route: 15

Route for vehicle 3:
 0 Load(0) ->  9 Load(1) ->  8 Load(9) ->  6 Load(13) ->  5 Load(15) ->  0 Load(15)
Distance of the route: 1164m
Load of the route: 15

Total distance of all routes: 6872m
Total load of all routes: 60

--------------------------------------------------------------------------


Seems so! What if we move the file to a completely different location?
--------------------------------------------------------------------------
C:\Users\jc321076\Documents>python external_data_routing.py
Route for vehicle 0:
 0 Load(0) ->  1 Load(1) ->  4 Load(5) ->  3 Load(7) ->  15 Load(15) ->  0 Load(15)
Distance of the route: 2192m
Load of the route: 15

Route for vehicle 1:
 0 Load(0) ->  14 Load(4) ->  16 Load(12) ->  10 Load(14) ->  2 Load(15) ->  0 Load(15)
Distance of the route: 2192m
Load of the route: 15

Route for vehicle 2:
 0 Load(0) ->  7 Load(8) ->  13 Load(12) ->  12 Load(14) ->  11 Load(15) ->  0 Load(15)
Distance of the route: 1324m
Load of the route: 15

Route for vehicle 3:
 0 Load(0) ->  9 Load(1) ->  8 Load(9) ->  6 Load(13) ->  5 Load(15) ->  0 Load(15)
Distance of the route: 1164m
Load of the route: 15

Total distance of all routes: 6872m
Total load of all routes: 60

--------------------------------------------------------------------------


Yup, seems to work! Okay, now I  want to summon both or-tools and VRPModelling in separate folder.
I moved external_data_routing.py back into the github folder that contains both or-tools and VRPModelling folders.
I changed the number for vehicles from 4 to 1:
--------------------------------------------------------------------------
C:\Users\jc321076\github>python external_data_routing.py

C:\Users\jc321076\github>

--------------------------------------------------------------------------


It spend maybe 5 minutes running and did not produce anything.
It seems that or-tools doesn't by default understand "one vehicle making multiple routes".
For now, we can workaround it by having lots of dummy vehicles, each one representing a trip made by the single vehicle.

  data['vehicle_capacities'] = [15, 15, 15, 15, 15, 15, 15, 15, 15, 15]  # TODO: make this dependent on num of vehicles for bandaid
    data['num_vehicles'] = 10  # larger number, higher than the number of routes

This won't work for a dynamic case, because events turn up on a timeline.
Anyway, I'll use the workaround for now and deal with it at the dynamic stage.
--------------------------------------------------------------------------
C:\Users\jc321076\github>python external_data_routing.py
Route for vehicle 0:
 0 Load(0) ->  0 Load(0)
Distance of the route: 0m
Load of the route: 0

Route for vehicle 1:
 0 Load(0) ->  1 Load(1) ->  4 Load(5) ->  3 Load(7) ->  15 Load(15) ->  0 Load(15)
Distance of the route: 2192m
Load of the route: 15

Route for vehicle 2:
 0 Load(0) ->  14 Load(4) ->  16 Load(12) ->  10 Load(14) ->  2 Load(15) ->  0 Load(15)
Distance of the route: 2192m
Load of the route: 15

Route for vehicle 3:
 0 Load(0) ->  7 Load(8) ->  13 Load(12) ->  12 Load(14) ->  11 Load(15) ->  0 Load(15)
Distance of the route: 1324m
Load of the route: 15

Route for vehicle 4:
 0 Load(0) ->  9 Load(1) ->  8 Load(9) ->  6 Load(13) ->  5 Load(15) ->  0 Load(15)
Distance of the route: 1164m
Load of the route: 15

Total distance of all routes: 6872m
Total load of all routes: 60

--------------------------------------------------------------------------


There is an extra empty route there, so I know there are enough dummy vehicles assigned.

Now, I want to import my VRPModeling classes into external_data_routing.py:

  from VRPModeling.Depot import Depot
  depot1 = Depot(0, [0, 0])
  print(depot1.__str__())

I comment out the print_solution() command so the output is less cluttered.
Running it:
--------------------------------------------------------------------------
C:\Users\jc321076\github>python external_data_routing.py
Traceback (most recent call last):
  File "external_data_routing.py", line 8, in <module>
    from VRPModeling.Depot import Depot
  File "C:\Users\jc321076\github\VRPModeling\Depot.py", line 1, in <module>
    from Node import Node
ModuleNotFoundError: No module named 'Node'

--------------------------------------------------------------------------


So the issue isn't the first import, but the import line within Depoty.py, because it assumes Node.py is in the same folder, but external_data_routing.py doesn't know where Node.py is.
According to this stack overflow answer, we can use a relative reference to fix this:
https://stackoverflow.com/questions/40397851/python-cant-find-a-module-that-is-imported-in-another-module
I modify Depot.py in VRPModeling:

  from .Node import Node

And run again:
--------------------------------------------------------------------------
C:\Users\jc321076\github>python external_data_routing.py
Depot.id = 0
Depot.location = [0, 0]
--------------------------------------------------------------------------


Excellent. I modify all imports in VRPModeling classes to a relative reference.
Then I create add more objects needed for a VRP instance (just the dummy instance found in VRPModeling's sandbox):

  from Vehicle import Vehicle
  vehicle1 = Vehicle(11, 0.8)
  print(vehicle1.__str__())

  from VRPInstance import VRPInstance
  vrp1 = VRPInstance(vehicle1, depot1)

  from Node import Node
  import random
  random.seed(7)
  for i in range(7):
      x = random.randrange(12)
      y = random.randrange(15)
      demand = random.randrange(5, 50, 5)
      vrp1.add_node([x, y], demand)
  print(vrp1.__str__())
  print(vrp1.nodes_details())

Running it:
--------------------------------------------------------------------------
C:\Users\jc321076\github>python external_data_routing.py
Depot.id = 0
Depot.location = [0, 0]
Vehicle.capacities = 11
Vehicle.variable_cost = 0.8
name = Andersen_n8
Vehicle.capacities = 11
Vehicle.variable_cost = 0.8
Depot.id = 0
Depot.location = [0, 0]
nodes in instance: 7
arcs in instance: 7
id    location    demand
1     [5, 2]      35
2     [10, 0]      10
3     [8, 1]      30
4     [9, 0]      45
5     [3, 0]      10
6     [6, 6]      10
7     [3, 1]      45

--------------------------------------------------------------------------


Now I want VRPModeling to spit out data that is digestible by or-tools.
I created a function called get_distance_matrix() in VRPInstance.
I want to store the distance matrix as a sparse matrix since not all nodes will necessarily have arcs connecting them.
I'm assuming that numpy's array is best for the job, but happy to change if not the case.

...I just realised that or-tools doesn't actually need a distance matrix.
It uses a distance callback - in the example program, it is defined as below:

  def distance_callback(from_index, to_index):
      """Returns the distance between the two nodes.
      Basically the way the system internally accesses the distance matrix
      """

      # Convert from routing variable Index to distance matrix NodeIndex.
      from_node = manager.IndexToNode(from_index)
      to_node = manager.IndexToNode(to_index)
      return data['distance_matrix'][from_node][to_node]

So I can redefine the distance callback to pull distances straight from VRPInstance's arcs list, instead from a distance matrix!
(I also refactored Node.id as an int, and arcs keys as the Node id)
The new redefinition:

  def distance_callback(from_index, to_index):
      """Returns the distance between the two nodes. Distance MUST BE INTEGER!
      Distance values are scaled by 100. Note that solution printer must scale down by 100.

      Basically the way the system internally accesses the distance matrix.
      """

      # Convert from routing variable Index to distance matrix NodeIndex.
      from_node = manager.IndexToNode(from_index)
      to_node = manager.IndexToNode(to_index)
      distance = vrp_instance.arcs[from_node][to_node].distance
      distance = int(round(distance * 100))  # scaling to keep float precision
      print("distance from node {0} to node {1} is {2}\n".format(from_node, to_node, distance))

      return distance

  distance_callback(1, 2)

I call distance_callback to check that it's working.
Yes, the distance given is a scale version of the value from the distance matrix.
(remember that node 0 is the first column of the distance matrix)
--------------------------------------------------------------------------

[[ 0.          5.38516481  1.          5.09901951  8.54400375  6.08276253
   3.16227766 10.        ]
 [ 5.38516481  0.          5.09901951  5.          3.16227766  5.65685425
   4.12310563  5.        ]
 [ 1.          5.09901951  0.          4.12310563  8.24621125  5.09901951
   2.23606798  9.43398113]
 [ 5.09901951  5.          4.12310563  0.          7.28010989  1.
   2.          7.07106781]
 [ 8.54400375  3.16227766  8.24621125  7.28010989  0.          7.61577311
   7.          3.        ]
 [ 6.08276253  5.65685425  5.09901951  1.          7.61577311  0.
   3.          7.        ]
 [ 3.16227766  4.12310563  2.23606798  2.          7.          3.
   0.          7.61577311]
 [10.          5.          9.43398113  7.07106781  3.          7.
   7.61577311  0.        ]]
distance from node 1 to node 2 is 510
Route for vehicle 0:
 0 Load(0) ->  0 Load(0)
Distance of the route: 0m
Load of the route: 0

Route for vehicle 1:
 0 Load(0) ->  0 Load(0)
Distance of the route: 0m
Load of the route: 0

Route for vehicle 2:
 0 Load(0) ->  0 Load(0)
Distance of the route: 0m
Load of the route: 0

Route for vehicle 3:
 0 Load(0) ->  4 Load(4) ->  3 Load(6) ->  1 Load(7) ->  0 Load(7)
Distance of the route: 0m
Load of the route: 7

Route for vehicle 4:
 0 Load(0) ->  7 Load(8) ->  6 Load(12) ->  5 Load(14) ->  2 Load(15) ->  0 Load(15)
Distance of the route: 0m
Load of the route: 15

Total distance of all routes: 0m
Total load of all routes: 22

--------------------------------------------------------------------------


But the distances given in the solution is 0! Why?
I go back to the old distance callback:
--------------------------------------------------------------------------

Route for vehicle 0:
 0 Load(0) ->  0 Load(0)
Distance of the route: 0m
Load of the route: 0

Route for vehicle 1:
 0 Load(0) ->  0 Load(0)
Distance of the route: 0m
Load of the route: 0

Route for vehicle 2:
 0 Load(0) ->  0 Load(0)
Distance of the route: 0m
Load of the route: 0

Route for vehicle 3:
 0 Load(0) ->  5 Load(2) ->  6 Load(6) ->  2 Load(7) ->  1 Load(8) ->  4 Load(12) ->  3 Load(14) ->  0 Load(14)
Distance of the route: 2464m
Load of the route: 14

Route for vehicle 4:
 0 Load(0) ->  7 Load(8) ->  0 Load(8)
Distance of the route: 388m
Load of the route: 8

Total distance of all routes: 2852m
Total load of all routes: 22
[Finished in 1.764s]

--------------------------------------------------------------------------

So the old distance callback works.
Let's try putting our VRPInstance through create_data_model():.

    def create_data_model(vrp_instance):  # We can replace this with a VRPModeling structure?, or a read-in
        """Stores the data for the problem. Creates a dictionary, to be exact. """

        data = {}
        data['distance_matrix'] = vrp_instance.get_distance_matrix()
        print(data['distance_matrix'])

We print out the distance matrix to make sure it works.
--------------------------------------------------------------------------
[[ 0.          5.38516481  1.          5.09901951  8.54400375  6.08276253  3.16227766 10.        ]
 [ 5.38516481  0.          5.09901951  5.          3.16227766  5.65685425  4.12310563  5.        ]
 [ 1.          5.09901951  0.          4.12310563  8.24621125  5.09901951  2.23606798  9.43398113]
 [ 5.09901951  5.          4.12310563  0.          7.28010989  1.          2.          7.07106781]
 [ 8.54400375  3.16227766  8.24621125  7.28010989  0.          7.61577311  7.          3.        ]
 [ 6.08276253  5.65685425  5.09901951  1.          7.61577311  0.          3.          7.        ]
 [ 3.16227766  4.12310563  2.23606798  2.          7.          3.          0.          7.61577311]
 [10.          5.          9.43398113  7.07106781  3.          7.          7.61577311  0.        ]]
Route for vehicle 0:
 0 Load(0) ->  0 Load(0)
Distance of the route: 0m
Load of the route: 0

Route for vehicle 1:
 0 Load(0) ->  0 Load(0)
Distance of the route: 0m
Load of the route: 0

Route for vehicle 2:
 0 Load(0) ->  0 Load(0)
Distance of the route: 0m
Load of the route: 0

Route for vehicle 3:
 0 Load(0) ->  1 Load(1) ->  4 Load(5) ->  7 Load(13) ->  0 Load(13)
Distance of the route: 21m
Load of the route: 13

Route for vehicle 4:
 0 Load(0) ->  2 Load(1) ->  6 Load(5) ->  3 Load(7) ->  5 Load(9) ->  0 Load(9)
Distance of the route: 12m
Load of the route: 9

Total distance of all routes: 33m
Total load of all routes: 22
[Finished in 0.398s]
--------------------------------------------------------------------------

Hm. The distance still shows.
More interestingly the solution is different from when the distance callback used arcs.
Is it because distance matrix values are floats?
or-tools supposedly needs integer values, but it seems to produce a solution anyway?
Let's try scaling and rounding to an integer:

data['distance_matrix'] = np.rint(vrp_instance.get_distance_matrix() * 100)

The solution might change due to precision:
--------------------------------------------------------------------------

[[   0.  539.  100.  510.  854.  608.  316. 1000.]
 [ 539.    0.  510.  500.  316.  566.  412.  500.]
 [ 100.  510.    0.  412.  825.  510.  224.  943.]
 [ 510.  500.  412.    0.  728.  100.  200.  707.]
 [ 854.  316.  825.  728.    0.  762.  700.  300.]
 [ 608.  566.  510.  100.  762.    0.  300.  700.]
 [ 316.  412.  224.  200.  700.  300.    0.  762.]
 [1000.  500.  943.  707.  300.  700.  762.    0.]]
Route for vehicle 0:
 0 Load(0) ->  0 Load(0)
Distance of the route: 0m
Load of the route: 0

Route for vehicle 1:
 0 Load(0) ->  0 Load(0)
Distance of the route: 0m
Load of the route: 0

Route for vehicle 2:
 0 Load(0) ->  0 Load(0)
Distance of the route: 0m
Load of the route: 0

Route for vehicle 3:
 0 Load(0) ->  1 Load(1) ->  4 Load(5) ->  7 Load(13) ->  0 Load(13)
Distance of the route: 2155m
Load of the route: 13

Route for vehicle 4:
 0 Load(0) ->  6 Load(4) ->  3 Load(6) ->  5 Load(8) ->  2 Load(9) ->  0 Load(9)
Distance of the route: 1226m
Load of the route: 9

Total distance of all routes: 3381m
Total load of all routes: 22
[Finished in 0.469s]

--------------------------------------------------------------------------


Okay, weird. The solution did change slightly.
But it's really similar to the previous solution, with the same nodes in each route.
Just the order in the second route is swapped around.
It's still not similar to the arcs distance callback though.

I want to directly pull the distances from arcs instead of having to got through the get_distance_matrix() function.
A thought: VRPInstance.arcs doesn't actually store arcs going from a node to itself.
Distance matrices on the other hand store zeros on the diagonal. Does that matter?

    def distance_callback(from_index, to_index):

        # Convert from routing variable Index to distance matrix NodeIndex.
        from_node = manager.IndexToNode(from_index)
        to_node = manager.IndexToNode(to_index)
        if from_node == to_node:
            distance = 0
        else:
            distance = (vrp_instance.arcs[from_node][to_node]).distance
            distance = round(distance * 100)
        return distance

Now:
--------------------------------------------------------------------------

Route for vehicle 0:
 0 Load(0) ->  0 Load(0)
Distance of the route: 0m
Load of the route: 0

Route for vehicle 1:
 0 Load(0) ->  0 Load(0)
Distance of the route: 0m
Load of the route: 0

Route for vehicle 2:
 0 Load(0) ->  0 Load(0)
Distance of the route: 0m
Load of the route: 0

Route for vehicle 3:
 0 Load(0) ->  1 Load(1) ->  4 Load(5) ->  7 Load(13) ->  0 Load(13)
Distance of the route: 2155m
Load of the route: 13

Route for vehicle 4:
 0 Load(0) ->  6 Load(4) ->  3 Load(6) ->  5 Load(8) ->  2 Load(9) ->  0 Load(9)
Distance of the route: 1226m
Load of the route: 9

Total distance of all routes: 3381m
Total load of all routes: 22
[Finished in 0.433s]

--------------------------------------------------------------------------


Yes! It was the zeroes!
The solution is the same as the old distance callback on the VRPInstance.
But showing the distance this time.
The bug is fixed!

I want to get rid of create_data_model() completely and transfer everything to create_random_vrp_instance().
The next task is to extract demands directly from vrp_instance.nodes[index].demand

    # Add Capacity constraint
    def demand_callback(from_index):
        "Returns the demand of the node"
        # Convert from routing variable Index to demands NodeIndex
        from_node = manager.IndexToNode(from_index)
        return data['demands'][from_node]
        return demand

Changed to:

        def demand_callback(from_index):
            from_node = manager.IndexToNode(from_index)
            demand = vrp_instance.nodes[from_node].demand
            print(demand)
            return demand

And the one reference in the solution printer is adjusted:

    route_load += vrp_instance.nodes[node_index].demand

I print the demand so we can see if it extract it properly:
--------------------------------------------------------------------------
id    location    demand
0     [0, 0]      0
1     [5, 2]      35
2     [0, 1]      45
3     [1, 5]      5
4     [8, 3]      5
5     [1, 6]      35
6     [1, 3]      10
7     [8, 6]      5
0
35
45
5
5
35
10
5
45
....
0
45
0
35
[Finished in 0.569s]
--------------------------------------------------------------------------


It extracts properly, but doesn't print out the solution?
Ah! What if there is no possible solution because the vehicle capacities are too small:

  data['vehicle_capacities'] = [15, 15, 15, 15, 15]

Let's reduce the demand range to 15 when we generate the demand in create_random_vrp_instance():

    demand = random.randrange(1, 15, 1)

Aaaaand:
--------------------------------------------------------------------------
id    location    demand
0     [0, 0]      0
1     [5, 2]      7
2     [0, 1]      14
3     [8, 1]      6
4     [9, 0]      9
5     [3, 0]      2
6     [6, 6]      2
7     [3, 1]      9
[0, 7, 14, 6, 9, 2, 2, 9]
Route for vehicle 0:
 0 Load(0) ->  0 Load(0)
Distance of the route: 0m
Load of the route: 0

Route for vehicle 1:
 0 Load(0) ->  3 Load(6) ->  4 Load(15) ->  0 Load(15)
Distance of the route: 1847m
Load of the route: 15

Route for vehicle 2:
 0 Load(0) ->  6 Load(2) ->  1 Load(9) ->  5 Load(11) ->  0 Load(11)
Distance of the route: 1844m
Load of the route: 11

Route for vehicle 3:
 0 Load(0) ->  7 Load(9) ->  0 Load(9)
Distance of the route: 632m
Load of the route: 9

Route for vehicle 4:
 0 Load(0) ->  2 Load(14) ->  0 Load(14)
Distance of the route: 200m
Load of the route: 14

Total distance of all routes: 4523m
Total load of all routes: 49
[Finished in 0.424s]

--------------------------------------------------------------------------


Next I want to get rid of data['vehicle_capacities'] and extract that number straight from create_random_vrp_instance():

  from VRPModeling.Vehicle import Vehicle
    vehicle1 = Vehicle(15)

Since my problem only has 1 vehicle with one capacity, we don't need the vector of vehicle capacities as found in the original:

    demand_callback_index = routing.RegisterUnaryTransitCallback(demand_callback)
      routing.AddDimensionWithVehicleCapacity(
          demand_callback_index,
          0,  # null capacity slack
          data['vehicle_capacities'],
          True,  # start culum to zero
          'Capacity')

Instead of AddDimensionWithVehicleCapacity(), we can just use AddDimension() with a single upper bound capacity:

    demand_callback_index = routing.RegisterUnaryTransitCallback(demand_callback)
    routing.AddDimension(
        demand_callback_index,
        0,  # null capacity slack https://developers.google.com/optimization/routing/dimensions#slack_variables
        vrp_instance.vehicle.capacity,
        True,  # start culum to zero
        'Capacity')

This should give us the same solution.
--------------------------------------------------------------------------

Route for vehicle 0:
 0 Load(0) ->  0 Load(0)
Distance of the route: 0m
Load of the route: 0

Route for vehicle 1:
 0 Load(0) ->  3 Load(6) ->  4 Load(15) ->  0 Load(15)
Distance of the route: 1847m
Load of the route: 15

Route for vehicle 2:
 0 Load(0) ->  6 Load(2) ->  1 Load(9) ->  5 Load(11) ->  0 Load(11)
Distance of the route: 1844m
Load of the route: 11

Route for vehicle 3:
 0 Load(0) ->  7 Load(9) ->  0 Load(9)
Distance of the route: 632m
Load of the route: 9

Route for vehicle 4:
 0 Load(0) ->  2 Load(14) ->  0 Load(14)
Distance of the route: 200m
Load of the route: 14
Total distance of all routes: 4523m
Total load of all routes: 49
[Finished in 0.4s]

--------------------------------------------------------------------------


Yep!

--------------------------------------------------------------------------
--------------------------------------------------------------------------
--------------------------------------------------------------------------
--------------------------------------------------------------------------

--------------------------------------------------------------------------
--------------------------------------------------------------------------
--------------------------------------------------------------------------
--------------------------------------------------------------------------

--------------------------------------------------------------------------
--------------------------------------------------------------------------
--------------------------------------------------------------------------
--------------------------------------------------------------------------
